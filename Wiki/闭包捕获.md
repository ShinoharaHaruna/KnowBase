---
title: 闭包捕获
date created: 2025-04-21 22:02:25
tags:
  - "#Golang"
  - "#闭包"
  - "#编程实践"
  - "#并发"
  - "#代码优化"
category: Golang
---

# 闭包捕获

## 摘要

在 Golang 中，闭包是一种特殊函数值，它引用了其外部作用域中的变量。简单来说，闭包能够“捕获”并“记住”其外部作用域中的变量，即使这些变量的生命周期已经结束，闭包仍然可以使用它们。这种特性使得闭包在许多场景下非常有用，但也可能导致一些意外行为，尤其是在涉及并发和循环时对变量的捕获方式。

## 什么是闭包

闭包是由函数和与其相关的引用环境组合而成的实体。在支持头等函数的编程语言中，如果一个函数内部定义了另一个函数，并且内部函数引用了外部函数的局部变量（自由变量），那么就会产生闭包。闭包与匿名函数经常一起使用，当匿名函数引用了外部作用域的变量时，就形成了闭包。

详细参见：[闭包](闭包.md)

## 闭包的变量捕获机制

Golang 中的闭包对外部变量的捕获方式是引用，而不是值的拷贝。这意味着闭包访问的是变量所在的内存地址，因此当外部变量的值发生改变时，闭包内部对该变量的访问也会反映出最新的值。

### 循环中的变量捕获陷阱

在 Go 语言中，当在循环内部创建闭包（如匿名函数）并启动 Goroutine 时，闭包会捕获循环变量的引用。由于循环变量在每次迭代中会被重用，所有 Goroutine 捕获的都是同一个变量的引用。当 Goroutine 真正执行时，循环可能已经结束，此时所有 Goroutine 访问到的循环变量都是其最终的值，这通常不是我们期望的结果。

**示例**：

```go
package main

import (
	"fmt"
)

func main() {
	var funcs []func()

	for i := 0; i < 3; i++ {
		funcs = append(funcs, func() {
			fmt.Println(i)
		})
	}

	for _, f := range funcs {
		f()
	}
}
```

这个程序的输出结果取决于 Go 的版本。在旧版本中，代码将输出：

```sh
3
3
3
```

这是因为闭包捕获的是循环变量 `i` 的引用，而不是在每次迭代时创建新的副本。当 `for` 循环结束时，`i` 的值已经变成了 `3`（因为 `i < 3` 不成立时循环终止），此时所有的闭包函数访问的都是同一个 `i` 的最终值。

在较新的 Go 版本（Go 1.22+）中，语言规范进行了调整，使得循环变量在每次迭代时都会创建新的副本，因此上述代码会输出：

```sh
0
1
2
```

### 解决循环变量捕获问题的方法

为了避免在循环中 Goroutine 闭包捕获同一个变量引用的问题，有几种常用的解决方法：

1. **创建新的局部变量**：在循环体内创建一个新的局部变量，将循环变量的值赋给它，然后让闭包捕获这个新的局部变量。这样每次迭代都会创建一个独立的变量副本供闭包使用。

```go
for i := 0; i < 3; i++ {
    current := i // 每次循环都会创建一个新的 current 变量
    funcs = append(funcs, func() {
        fmt.Println(current) // 闭包捕获的是当前迭代的 current
    })
}
```

2. **将循环变量作为参数传递给闭包**：将循环变量作为参数传递给匿名函数。这样，闭包会捕获参数的值，而不是外部循环变量的引用。

```go
for i := 0; i < 3; i++ {
    func(i int) {
        funcs = append(funcs, func() {
            fmt.Println(i) // 闭包捕获的是参数 i
        })
    }(i) // 立即调用并传入当前 i 的值
}
```

## GC

TODO: 下次再写……

## 闭包的应用场景

闭包在 Go 语言中有多种应用场景，例如：

- **数据隔离**：利用闭包可以创建拥有私有状态的函数，从而实现数据的隔离和封装。
- **延迟执行**：结合 `defer` 语句使用闭包，可以在函数返回前执行一些清理或收尾操作，并且可以访问到函数执行过程中的变量。
- **函数工厂**：闭包可以用来创建返回其他函数的函数，这些返回的函数可以根据创建时的环境拥有不同的行为。

## 信息框

| 特性         | 说明                                                                 |
| :----------- | :------------------------------------------------------------------- |
| 定义         | 引用了外部作用域变量的函数值                                         |
| 捕获机制     | 默认按引用捕获外部变量                                               |
| 常见问题     | 循环中 Goroutine 闭包捕获同一变量引用                                |
| 解决方法     | 创建新的局部变量或将变量作为参数传递给闭包（Go 1.22 已改进此行为） |
| 主要应用场景 | 数据隔离、延迟执行、函数工厂等                                       |
