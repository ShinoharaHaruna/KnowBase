---
title: Hash 函数的不动点
author:
  - David Lyness
date created: 2025-03-12 19:45:04
category: 计算机科学
tags:
  - "#计算机科学"
  - "#算法"
  - "#编程实践"
  - "#数学"
url:
  - https://blog.davidlyness.com/fixed-points-of-hash-functions/
description: 本文探讨了MD5哈希不动点的存在性问题，从数学原理出发，推导了哈希函数存在不动点的概率。同时，分析了MD5算法的特性，并讨论了实际寻找不动点的难度。最后，引申到Quine程序的概念，展示了代码自复制的有趣现象。
status: Finished
---

这篇文章的灵感源于我最近遇到的一个问题：“一个字符串的 `MD5` 哈希值是否有可能与其自身相等？” 答案是肯定的——从算法原理上来说，并没有什么根本性的约束来阻止这种情况的发生。然而，更有意思的挑战在于评估这种事件发生的概率。

`MD5` 哈希算法接收任意长度的字符串作为输入，并生成一个 128 位的输出结果，通常表示为 32 位的十六进制数。例如：

```
md5("test123") = c38f4ec93b73956709932e6464f4f339
md5("test456") = 0f3c7ce16f5c313b81a9e54758bcae8a
```

为了使一个字符串的哈希值与其自身相等，显然，该字符串本身必须恰好是 128 位，即 32 个十六进制字符。因此，一种直接（但略显笨拙）的方法是尝试所有可能的字符串，以寻找潜在的匹配。我们将搜索空间限定为所有长度恰好为 32 个十六进制字符的字符串，这意味着我们需要搜索的总字符串数为 $16^{32} = 2^{128}$。 即使以每秒一百万次哈希计算的适度速度，我们也需要大约 $1.079 \times 10^{25}$ 年才能尝试所有可能的组合。 因此，我们需要一种更高效的方法。

让我们首先从纯数学的角度出发，然后再讨论像 `MD5` 这样的具体函数。 在最基本的层面上，对于给定的函数 $f$，我们想要确定是否存在一个输入 $x$，满足：

$$
f(x) = x
$$

我们还掌握了关于 $f$ 的一些信息。 它是一个密码哈希函数，这意味着其输出始终是一个固定长度的字符串——假设以二进制表示时长度为 $n$。 这意味着 $x$ —— $f$ 的不动点候选者——也必须具有长度 $n$。 这为 $x$ 提供了总共 $2^n$ 个候选者。

密码哈希函数的另一个关键特性是，它们的设计目标是尽可能均匀地分布其输出结果，以最大限度地减少哈希冲突的可能性。 将 $f$ 建模为均匀分布，我们得到：

$$
\mathbb{P}\left({f\left(x\right)=x}\right)=\frac{1}{2^n}
$$

对于给定的 $x$。 作为中间步骤，让我们计算对于 $x$ 的所有可能值，$x$ 不是 $f$ 的不动点的概率。 这将是 $1-\frac{1}{2^{n}}$ 乘以 $x$ 的可能值的数量——因此，

$$
\mathbb{P}\left({\forall x:f\left(x\right)\not=x}\right)=\left({1-\frac{1}{2^n}}\right )^{2^n},
$$

由于 $\lim_{\alpha\rightarrow\infty}(1-\frac{1}{\alpha})^{\alpha}=\frac{1}{e}$，我们得到：

$$
\lim_{n \to \infty}\mathbb{P}\left({\forall x:f\left(x\right)\not=x}\right)=\frac{1}{e}
$$

现在，为了得到某个 $x$ 确实具有此属性的概率，我们计算其补集：

$$
\lim_{n \to \infty}\mathbb{P}\left({\exists x:f\left(x\right)=x}\right)=1-\frac{1}{e}
$$

因此，对于长度足够大的哈希函数，存在不动点的概率近似为 $1−\frac{1}{e}\approx 0.6321=63.21\%$。

回到 `MD5` 函数，它输出一个二进制长度为 128 的字符串。因此，$n=128$，并且由于 $2^{128}$ 是一个非常大的数字，`MD5` 算法存在不动点的概率非常接近 63.21%。 鉴于我们的数学方法是通用的，并且仅依赖于所有密码哈希函数共有的某些属性，因此它也适用于其他算法，例如 `SHA-1` ($n=160$) 和 `SHA-2` ($n=224$、$n=256$、$n=384$ 或 $n=512$)。

尽管上述计算预测了不动点的存在，但它并没有告诉我们如何找到它。 由于生日悖论，定位任意哈希冲突的过程相对容易，但即使是这些对于密码安全的哈希函数来说也是难以实现的。 就目前而言，我们不太可能在这些大 $n$ 哈希函数中找到这样的不动点，除非计算能力取得显著突破、算法本身存在数学上的弱点，或者有人非常幸运。

---

现在是对原文的一些想法：

1. 这个算法的假设当然是 MD5 的输出是在 $n=128$ 的空间上分布均匀了，但是事实很可能并非如此。
2. 计算 $\mathbb{P}\left({\forall x:f\left(x\right)\not=x}\right)=\left({1-\frac{1}{2^n}}\right )^{2^n}$ 依赖于一个假设，即对于不同的 $x$，事件 $f(x) = x$ 是独立的。但对于 MD5 来说，这件事可能不一定成立。

以及令人想到 Quine 问题，即代码的运行结果是代码本身。

请看示例：

```cpp
#include <stdio.h>
char*s="#include <stdio.h>%cchar*s=%c%s%c;%cint main(void){printf(s,10,34,s,34,10,10);}%c";
int main(void){printf(s,10,34,s,34,10,10);}
```

有：

```sh
$ ./quine | diff quine.cpp -

```

这意味着程序运行的结果是将程序本身打印了一份。非常有意思。

引申阅读：

- [Quien](https://en.wikipedia.org/wiki/Quine_(computing)#Examples)
- [C/C++ program that prints its own source code as its output](https://stackoverflow.com/questions/10238670/c-c-program-that-prints-its-own-source-code-as-its-output)
